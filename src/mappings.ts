import { BigInt, BigDecimal, Bytes, ethereum, Address, log } from "@graphprotocol/graph-ts"

import {
  Transfer as TransferWETHEvent,
  WETH,
} from "../generated/Treasury/WETH"
import {
  Transfer as TransferAXSEvent,
  AXS,
} from "../generated/Treasury/AXS"

import { Block, TreasuryTransfer } from "../generated/schema"

const AXS_ADDRESS = "0x97a9107c1793bc407d6f527b77e7fff4d812bece"
const WETH_ADDRESS = "0xc99a6a985ed2cac1ef41640596c5a5f9f4e19ef5"
const TREAUSRY_ADDRESS = "0x245db945c485b68fdc429e4f7085a1761aa4d45d"

// export function handleTransfer(event: TransferWETHEvent | TransferAXSEvent): void {
//   // let id = event.transaction.hash.toHex() + "-" + event.logIndex.toString()
//   let transfer = new TreasuryTransfer("auto")

//   transfer._from = event.params._from
//   transfer._to = event.params._to

//   transfer.blockNumber = event.block.number
//   transfer.blockTimestamp = event.block.timestamp
//   transfer.timestamp = event.block.timestamp.toI32()
//   transfer.transactionHash = event.transaction.hash
//   transfer.tokenAddress = event.address.toHexString()
//   transfer.source = "Treasury"
  
//   log.info('Message to be displayed: {}, {}, {}', [event.address.toHexString(), WETH_ADDRESS, 'already a string'])

//   // WETH inflow
//   if (
//     !event.params._value.isZero() &&
//     event.address.toHexString() == WETH_ADDRESS &&
//     event.params._to.toHexString() == TREAUSRY_ADDRESS
//   ) {
//     transfer.amountInflowETH = event.params._value.toBigDecimal()
//   }else{
//     transfer.amountInflowETH = BigDecimal.zero()
//   }

//   // WETH outflow
//   if (
//     !event.params._value.isZero() &&
//     event.address.toHexString() == WETH_ADDRESS &&
//     event.params._from.toHexString() == TREAUSRY_ADDRESS
//   ) {
//     transfer.amountOutflowETH = event.params._value.toBigDecimal()
//   } else {
//     transfer.amountOutflowETH = BigDecimal.zero()
//   }

//   transfer.save()
// }


export function handleBlock(block: ethereum.Block): void {
    // The id for timeseries is autogenerated; even if we set it to a real
    // value, it would be silently overwritten
    let blockEntity = new Block("auto");

    blockEntity.blockNumber = block.number;

    // // Bind the WETH contract
    // let wethContract = WETH.bind(Address.fromString(TREAUSRY_ADDRESS));
    // // Assuming the treasury address holds WETH, fetch the balance
    // let amountETH = wethContract.balanceOf(Address.fromString(TREAUSRY_ADDRESS));

    // // Bind the AXS contract (replace with actual contract binding if different)
    // let axsContract = WETH.bind(Address.fromString(TREAUSRY_ADDRESS));
    // // Fetch the AXS balance
    // let amountAXS = axsContract.balanceOf(Address.fromString(TREAUSRY_ADDRESS));

//   // // Fetch balances from the contract
//   // let contract = AxieInfinityTreasury.bind(Address.fromString("0x...treasury_address")); // Replace with actual address

//   // // Make sure your contract has these view functions!
//   // snapshot.amountETH = contract.getETHBalance();  
//   // snapshot.amountAXS = contract.getAXSBalance();  


//   snapshot.save();

    // Get transfer to Treasury and detect type inflow (breeding, marketplace, etc) or outflow (transfer to other address)

    // Assign the fetched balances to the block entity
    blockEntity.amountETH = new BigInt(i32(Math.floor(Math.random() * 100)));

    blockEntity.timestamp = block.timestamp.toI32();
    blockEntity.blockTimestamp = block.timestamp;
    blockEntity.save();
}